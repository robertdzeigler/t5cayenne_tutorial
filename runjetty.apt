Cliffs Notes

	* Run the jetty servlet container with mvn:run

	* Application is available at {{http://localhost:8080/pizzeria}}.

		* Brings up the "Index" page (result of tapestry processing Index.tml with corresponding Index.class)

	* Requests flow through multiple pipelines, to the "Dispatcher" chain of command.

		* Multiple Dispatchers:

			* AssetDispatcher

			* RootPathDispatcher

			* PageRenderRequestDispatcher

			* ComponentEventDispatcher

	* Request flow for this request:

		* TapestryFilter => HttpServletRequestHandler => RequestHandler => MasterDispatcher => RootPathDispatcher => PageRenderRequestHandler => Index.tml/Index.class

	{{{layout.html}Customize the look and feel}}.


Tome

* Running Jetty

	The tapestry quickstart archetype sets up the "jetty" maven plugin for us, which means that running the application is simple.  From the project root, in the command line, type:

+----+
mvn jetty:run
+----+

	This starts the jetty servlet runner, configured to run your web application.  Now point your browser to {{http://localhost:8080/pizzeria}}. You should see a page like:

[ PizzeriaIndexScreenshot.png ] Pizzeria Index Page, as generated by the archetype:create command.

	Let's take a look at how that request is being processed.  Tapestry uses the following set of services for request processing:

[RequestProcessing.png] Tapestry Request Processing

	The first service is the TapestryFilter.  This is the "app" servlet filter that was configured in web.xml; as such, it isn't actually an IOC service; it is the class that sets up a tapestry application.  When a request is sent, the filter intercepts the request and passes it on to the "HttpServletRequestHandler" pipeline.  

	HttpServletRequestHandler is a pipeline built from contributed HttpServletRequestFilter services.  This pipeline is in place primarily to mitigate differences between servlets and portlets (with portlet support forthcoming); you don't usually contribute anything to it.  The pipeline eventually passes off control to the "RequestHandler" service. 

	RequestHandler is a pipeline of "RequestFilter" contributions.  This is an extremely useful contribution point for performing IOC-backed processing on all requests.  What ServletFilter is to servlets, RequestFilter is to tapestry applications.  RequestHandler is also responsible for storing the current Reqest and Response objects in the "RequestGlobals" object. Eventually, RequestHandler hands control off to the MasterDispatcher service.  

	MasterDispatcher is a {{{http://tapestry.apache.org/tapestry5/yeah}"Chain of Command"}} service. It is configured with an ordered list of "Dispatchers".  Each dispatcher is responsible for handling a single request type.  Control is passed to each dispatcher in turn, which examines the request url to determine if it should handle the request.  If the dispatcher doesn't recognize the url-type, it returns false and control continues to the next dispatcher.  If it groks the url, it handles the request and returns true to indicate the request has been handled.  There is a dispatcher responsible for recognizing "asset" (images, etc.) requests (AssetDispatcher), page requests (PageRequestDispatcher), and "event" (form submissions, etc.) requests (ComponentEventDispatcher).  Finally, there is the "RootPathDispatcher" which examines the request to see if it points to a "root path": essentially a request for an "index" page.

	The RootPathDispatcher looks at the url to see if it matches a root path.  A root path is the root of the application context, so http://localhost:8080/pizzeria refers to the root path. This signals a request for the application's "Index" page.  Ultimately, the request is handled in exactly the same way as for the PageRequestDispatcher: the request is handed off to the "PageRenderRequestHandler", which is a pipeline of PageRenderRequestFilter objects that handle setting up and performing a page render.  The tapestry rendering process works by treating a page render as a finite-state machine.  That is, rendering is broken up into a set of states with transitions possible between some of the states to allow for complex rendering such as looping, skipping certain rendering states, wrapping template content with code-generated content, and so on.  That's all well and good, but rather complicated.  Fortunately, for many pages and components, all you have to know for now is that tapestry parses your template into a DOM, then streams that DOM to the client.

	Let's {{{layout.html}customize the look and feel}}.
